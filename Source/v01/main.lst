CCS PCM C Compiler, Version 4.065, 44948               26-dec.-14 18:15

               Filename: main.lst

               ROM used: 1803 words (22%)
                         Largest free fragment is 2048
               RAM used: 67 (18%) at main() level
                         89 (24%) worst case
               Stack:    7 worst case (5 in main + 2 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   676
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  BTFSS  0B.3
001A:  GOTO   01D
001B:  BTFSC  0B.0
001C:  GOTO   036
001D:  MOVLW  8C
001E:  MOVWF  04
001F:  BTFSS  00.1
0020:  GOTO   023
0021:  BTFSC  0C.1
0022:  GOTO   039
0023:  MOVF   22,W
0024:  MOVWF  04
0025:  MOVF   23,W
0026:  MOVWF  77
0027:  MOVF   24,W
0028:  MOVWF  78
0029:  MOVF   25,W
002A:  MOVWF  79
002B:  MOVF   26,W
002C:  MOVWF  7A
002D:  MOVF   27,W
002E:  MOVWF  7B
002F:  MOVF   20,W
0030:  MOVWF  0A
0031:  SWAPF  21,W
0032:  MOVWF  03
0033:  SWAPF  7F,F
0034:  SWAPF  7F,W
0035:  RETFIE
0036:  BCF    0A.3
0037:  BCF    0A.4
0038:  GOTO   143
0039:  BCF    0A.3
003A:  BCF    0A.4
003B:  GOTO   17F
.................... #include <16f877a.h>                    
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOPROTECT,PUT,NOLVP  
.................... #device adc=10                      //  A/D  de 10 bits 
.................... #use delay (clock=4000000)   
*
0196:  MOVLW  65
0197:  MOVWF  04
0198:  BCF    03.7
0199:  MOVF   00,W
019A:  BTFSC  03.2
019B:  GOTO   1AA
019C:  MOVLW  01
019D:  MOVWF  78
019E:  CLRF   77
019F:  DECFSZ 77,F
01A0:  GOTO   19F
01A1:  DECFSZ 78,F
01A2:  GOTO   19E
01A3:  MOVLW  4A
01A4:  MOVWF  77
01A5:  DECFSZ 77,F
01A6:  GOTO   1A5
01A7:  GOTO   1A8
01A8:  DECFSZ 00,F
01A9:  GOTO   19C
01AA:  RETLW  00
.................... #use I2C(MASTER,FAST=100000, SDA=PIN_C4, SCL=PIN_C3,FORCE_HW) 
*
0133:  BCF    14.7
0134:  BCF    0C.3
0135:  MOVF   72,W
0136:  MOVWF  13
0137:  MOVLW  02
0138:  BTFSC  14.7
0139:  GOTO   141
013A:  BTFSS  0C.3
013B:  GOTO   13A
013C:  MOVLW  00
013D:  BSF    03.5
013E:  BTFSC  11.6
013F:  MOVLW  01
0140:  BCF    03.5
0141:  MOVWF  78
0142:  RETLW  00
*
015D:  BSF    03.5
015E:  BSF    11.3
015F:  BTFSC  11.3
0160:  GOTO   15F
0161:  BTFSC  77.0
0162:  BCF    11.5
0163:  BTFSS  77.0
0164:  BSF    11.5
0165:  BSF    11.4
0166:  BTFSC  11.4
0167:  GOTO   166
0168:  BCF    03.5
0169:  MOVF   13,W
016A:  MOVWF  78
*
0691:  MOVLW  FF
0692:  BCF    03.5
0693:  MOVWF  29
....................  
.................... // Debug code 
....................  
.................... // Includes 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
0694:  CLRF   2A
0695:  CLRF   2B
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h>                      // Necessario para funcao atol ou atoi 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
....................  
.................... /* Standard template:  atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
....................  // This function is called strtod in PCM/PCH 
....................  // This ensures compatibility between compilers 
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr);  
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
.................... #if !defined(__PCD__) 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
....................  
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "LCD.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCDD.C                                //// 
.................... ////                 Driver for common LCD modules                     //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     D0  enable 
.................... //     D1  rs 
.................... //     D2  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used. 
....................  
.................... // Un-comment the following define to use port B 
.................... // #define use_portb_lcd TRUE 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN enable;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN unused;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................  
....................  
.................... #if defined use_portb_lcd 
....................    //#locate lcd = getenv("sfr:PORTB")    // This puts the entire structure over the port 
....................    #ifdef __pch__ 
....................     #locate lcd = 0xf81 
....................    #else 
....................     #locate lcd = 6 
....................    #endif 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    //#locate lcd = getenv("sfr:PORTD")    // This puts the entire structure over the port 
....................    #ifdef __pch__ 
....................     #locate lcd = 0xf83 
....................    #else 
....................     #locate lcd = 8 
....................    #endif 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
.................... #ifndef lcd_type 
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
*
01B8:  MOVLW  F0
01B9:  BSF    03.5
01BA:  MOVWF  08
....................       lcd.rw = 1; 
01BB:  BCF    03.5
01BC:  BSF    08.2
....................       delay_cycles(1); 
01BD:  NOP
....................       lcd.enable = 1; 
01BE:  BSF    08.0
....................       delay_cycles(1); 
01BF:  NOP
....................       high = lcd.data; 
01C0:  MOVF   08,W
01C1:  SWAPF  08,W
01C2:  ANDLW  0F
01C3:  MOVWF  65
....................       lcd.enable = 0; 
01C4:  BCF    08.0
....................       delay_cycles(1); 
01C5:  NOP
....................       lcd.enable = 1; 
01C6:  BSF    08.0
....................       delay_us(1); 
01C7:  NOP
....................       low = lcd.data; 
01C8:  MOVF   08,W
01C9:  SWAPF  08,W
01CA:  ANDLW  0F
01CB:  MOVWF  64
....................       lcd.enable = 0; 
01CC:  BCF    08.0
....................       set_tris_lcd(LCD_WRITE); 
01CD:  MOVLW  00
01CE:  BSF    03.5
01CF:  MOVWF  08
....................       return( (high<<4) | low); 
01D0:  BCF    03.5
01D1:  SWAPF  65,W
01D2:  MOVWF  77
01D3:  MOVLW  F0
01D4:  ANDWF  77,F
01D5:  MOVF   77,W
01D6:  IORWF  64,W
01D7:  MOVWF  78
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
01AB:  SWAPF  65,W
01AC:  ANDLW  F0
01AD:  MOVWF  77
01AE:  MOVLW  0F
01AF:  ANDWF  08,W
01B0:  IORWF  77,W
01B1:  MOVWF  08
....................       delay_cycles(1); 
01B2:  NOP
....................       lcd.enable = 1; 
01B3:  BSF    08.0
....................       delay_us(2); 
01B4:  GOTO   1B5
....................       lcd.enable = 0; 
01B5:  BCF    08.0
.................... } 
01B6:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
01B7:  BCF    08.1
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
*
01D8:  MOVF   78,W
01D9:  MOVWF  64
01DA:  BTFSC  64.7
01DB:  GOTO   1B8
....................       lcd.rs = address; 
01DC:  BTFSS  62.0
01DD:  BCF    08.1
01DE:  BTFSC  62.0
01DF:  BSF    08.1
....................       delay_cycles(1); 
01E0:  NOP
....................       lcd.rw = 0; 
01E1:  BCF    08.2
....................       delay_cycles(1); 
01E2:  NOP
....................       lcd.enable = 0; 
01E3:  BCF    08.0
....................       lcd_send_nibble(n >> 4); 
01E4:  SWAPF  63,W
01E5:  MOVWF  64
01E6:  MOVLW  0F
01E7:  ANDWF  64,F
01E8:  MOVF   64,W
01E9:  MOVWF  65
01EA:  CALL   1AB
....................       lcd_send_nibble(n & 0xf); 
01EB:  MOVF   63,W
01EC:  ANDLW  0F
01ED:  MOVWF  64
01EE:  MOVWF  65
01EF:  CALL   1AB
.................... } 
01F0:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
01F1:  MOVLW  00
01F2:  BSF    03.5
01F3:  MOVWF  08
....................     lcd.rs = 0; 
01F4:  BCF    03.5
01F5:  BCF    08.1
....................     lcd.rw = 0; 
01F6:  BCF    08.2
....................     lcd.enable = 0; 
01F7:  BCF    08.0
....................     delay_ms(15); 
01F8:  MOVLW  0F
01F9:  MOVWF  65
01FA:  CALL   196
....................     for(i=1;i<=3;++i) { 
01FB:  MOVLW  01
01FC:  MOVWF  5C
01FD:  MOVF   5C,W
01FE:  SUBLW  03
01FF:  BTFSS  03.0
0200:  GOTO   209
....................        lcd_send_nibble(3); 
0201:  MOVLW  03
0202:  MOVWF  65
0203:  CALL   1AB
....................        delay_ms(5); 
0204:  MOVLW  05
0205:  MOVWF  65
0206:  CALL   196
....................     } 
0207:  INCF   5C,F
0208:  GOTO   1FD
....................     lcd_send_nibble(2); 
0209:  MOVLW  02
020A:  MOVWF  65
020B:  CALL   1AB
....................     for(i=0;i<=3;++i) 
020C:  CLRF   5C
020D:  MOVF   5C,W
020E:  SUBLW  03
020F:  BTFSS  03.0
0210:  GOTO   21A
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
0211:  MOVF   5C,W
0212:  CALL   03C
0213:  MOVWF  5D
0214:  CLRF   62
0215:  MOVF   5D,W
0216:  MOVWF  63
0217:  CALL   1B7
0218:  INCF   5C,F
0219:  GOTO   20D
.................... } 
021A:  RETLW  00
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
021B:  DECFSZ 5F,W
021C:  GOTO   21E
021D:  GOTO   221
....................      address=lcd_line_two; 
021E:  MOVLW  40
021F:  MOVWF  60
....................    else 
0220:  GOTO   222
....................      address=0; 
0221:  CLRF   60
....................    address+=x-1; 
0222:  MOVLW  01
0223:  SUBWF  5E,W
0224:  ADDWF  60,F
....................    lcd_send_byte(0,0x80|address); 
0225:  MOVF   60,W
0226:  IORLW  80
0227:  MOVWF  61
0228:  CLRF   62
0229:  MOVF   61,W
022A:  MOVWF  63
022B:  CALL   1B7
.................... } 
022C:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
022D:  MOVF   5D,W
022E:  XORLW  0C
022F:  BTFSC  03.2
0230:  GOTO   238
0231:  XORLW  06
0232:  BTFSC  03.2
0233:  GOTO   240
0234:  XORLW  02
0235:  BTFSC  03.2
0236:  GOTO   246
0237:  GOTO   24B
....................      case '\f'   : lcd_send_byte(0,1); 
0238:  CLRF   62
0239:  MOVLW  01
023A:  MOVWF  63
023B:  CALL   1B7
....................                    delay_ms(2); 
023C:  MOVLW  02
023D:  MOVWF  65
023E:  CALL   196
....................                                            break; 
023F:  GOTO   251
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
0240:  MOVLW  01
0241:  MOVWF  5E
0242:  MOVLW  02
0243:  MOVWF  5F
0244:  CALL   21B
0245:  GOTO   251
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
0246:  CLRF   62
0247:  MOVLW  10
0248:  MOVWF  63
0249:  CALL   1B7
024A:  GOTO   251
....................      default     : lcd_send_byte(1,c);     break; 
024B:  MOVLW  01
024C:  MOVWF  62
024D:  MOVF   5D,W
024E:  MOVWF  63
024F:  CALL   1B7
0250:  GOTO   251
....................    } 
.................... } 
0251:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #use fast_io(C) 
....................  
....................  
.................... // Defines 
.................... #define NPOTENTIOMETERS 4 
.................... #define SIZEBUFFER 16 
....................  
.................... // Base address for the PCF'S 
.................... // Read 
.................... #define PCFBUTTONADDRESS 0xFF // Check 
....................  
.................... // Write 
.................... #define PCFLEDBUTTONADDRESS 0x42 
.................... #define PCFLINERECADDRESS 0x40 
.................... #define PCFPHONOADDRESS 
.................... #define PCFLCDDDRESS 
....................  
.................... // Redifines Pin interrupt 
.................... #define BUTOONPRESSED PIN_B7 
....................  
....................  
.................... // Decode the buttons 
.................... #define LINEUP       0x01 
.................... #define LINEDOWN     0x02 
.................... #define LINEUPDOWN   0x03 
....................  
.................... #define RECUP        0x04 
.................... #define RECDOWN      0x08 
.................... #define RECUPDOWN     0x0C 
....................  
.................... #define DIRECT 
.................... #define LOUD 
....................  
....................  
.................... // Set Threshold for adc detections 
.................... #define ADCTHRESHOLDDETECTION 0x05 
....................  
.................... // Scheduler 
.................... #define SCHEDULINGTIMEPERIOD 10 
....................  
.................... // Macros for convertion 
.................... #define CONVERTADCTOPERCENTAGE(VAL)((VAL/1024)*100) 
.................... #define CONVERTADCTODB(VAL)(((VAL-512)/512)*12) 
....................  
.................... // Names for the devices 
.................... const char *nameRecLine[] = {"TAPE1","TAPE2","TAPE3","CD","TUNER","SLOT1","SLOT2","MUTE"}; 
....................  
....................  
.................... // Global Variables 
.................... unsigned int16 bufferPotNew[NPOTENTIOMETERS]; 
.................... unsigned int16 bufferPotOld[NPOTENTIOMETERS]; 
....................  
.................... unsigned int8 pcfButton;      // Buffer for buttons 
.................... char buffer [SIZEBUFFER]; 
.................... unsigned int8 flagKeyPressed, flagLCDUpdate; 
.................... unsigned int8 lineChannel, recChannel, ledButton; 
....................  
.................... int1 flagScheduling=0;    // Flag for sheduling scaler 
*
0696:  BCF    56.0
....................  
.................... unsigned int8 x,y; 
....................  
.................... // Prototipes 
.................... void tecla_pulsada(void); 
.................... unsigned int8 readPCFButtons(unsigned int8 address); 
.................... void decodePressedButton(unsigned int8 data); 
.................... void initLcd (void); 
.................... void long_delay_ms(int16 count); 
.................... void configGPIO(void); 
.................... void configADC(void); 
.................... void readADCS(void); 
.................... void checkADCChanges(void); 
.................... void setLineRecChannel(unsigned int8 address, unsigned int8 lineChannel,unsigned int8 recChannel, unsigned int8 recActive); 
.................... void updateLCD(char* buffer, unsigned int8 line); 
.................... void saveCurrentValues(void); 
.................... void restoreSavedValues(void); 
.................... void setPGAValue(unsigned int16 volume, unsigned int16 balance); 
.................... void setToneValue(unsigned int16 bass, unsigned int16 tremble); 
....................  
....................  
....................  
....................  
.................... /////////////////////INTERRUPT ZONE////////////////////////// 
.................... // Interrupt: Check witch button is pressed 
.................... #INT_RB 
.................... void tecla_pulsada(void){ 
....................  
....................  
....................    if(!(input_b()^0xF0)) 
*
0143:  MOVLW  FF
0144:  BSF    03.5
0145:  MOVWF  06
0146:  BCF    03.5
0147:  MOVF   06,W
0148:  XORLW  F0
0149:  BTFSC  03.2
....................       return;                  // Return: all interrupts cleared 
014A:  GOTO   17B
....................  
....................    if((!input(BUTOONPRESSED))) 
014B:  BSF    03.5
014C:  BSF    06.7
014D:  BCF    03.5
014E:  BTFSC  06.7
014F:  GOTO   17B
....................          { 
....................             pcfButton=readPCFButtons(PCFBUTTONADDRESS);             // Pulser detected 
0150:  MOVLW  FF
0151:  MOVWF  6F
*
0175:  MOVF   78,W
0176:  BCF    03.5
0177:  MOVWF  40
....................             flagKeyPressed=1; 
0178:  MOVLW  01
0179:  MOVWF  51
....................             return; 
017A:  GOTO   17B
....................          } 
....................  
.................... } 
....................  
....................  
.................... // Interrup: Timer2 Interrupt 
017B:  BCF    0B.0
017C:  BCF    0A.3
017D:  BCF    0A.4
017E:  GOTO   023
.................... #INT_TIMER2  
.................... void timer2_isr(void) {  
....................    //Keep variables that are local _local_  
....................    static int8 tick;  
*
0697:  CLRF   59
....................    if (tick == SCHEDULINGTIMEPERIOD){ 
*
017F:  MOVF   59,W
0180:  SUBLW  0A
0181:  BTFSS  03.2
0182:  GOTO   185
....................       // clean the tick counter 
....................       tick =0; 
0183:  CLRF   59
....................       // rise the flag for scheduling 
....................       flagScheduling =TRUE; 
0184:  BSF    56.0
....................    } 
....................    tick++; 
0185:  INCF   59,F
.................... }  
....................  
....................  
....................  
.................... ////////////////FUNCTIONS ZONE//////////////////////////////// 
.................... // Function: readPCF 
0186:  BCF    0C.1
0187:  BCF    0A.3
0188:  BCF    0A.4
0189:  GOTO   023
.................... unsigned int8 readPCFButtons(unsigned int8 address){ 
.................... unsigned int8 data; 
....................    // Disable all 
....................    i2c_start (); 
*
0152:  BSF    03.5
0153:  BSF    11.0
0154:  BTFSC  11.0
0155:  GOTO   154
....................    i2c_write (address+1); 
0156:  MOVLW  01
0157:  BCF    03.5
0158:  ADDWF  6F,W
0159:  MOVWF  71
015A:  MOVWF  72
015B:  CALL   133
....................    data=i2c_read (0); 
015C:  CLRF   77
*
016B:  MOVF   78,W
016C:  MOVWF  70
....................    i2c_stop(); 
016D:  BSF    03.5
016E:  BSF    11.2
016F:  BTFSC  11.2
0170:  GOTO   16F
....................    data=data&0x3F;   // mask the two higher bits 
0171:  MOVLW  3F
0172:  ANDWF  70,F
....................    return data; 
0173:  MOVF   70,W
0174:  MOVWF  78
....................  
.................... } 
....................  
....................  
.................... // Function: decode the pressed key  
.................... void decodePressedButton(unsigned int8 data){ 
.................... unsigned int8 decode; 
....................  
....................    decode=(data&0x0f);  // Clean Buttons (Apply at the end) 
*
0332:  MOVF   5C,W
0333:  ANDLW  0F
0334:  MOVWF  5D
....................    switch(data){ 
0335:  MOVF   5C,W
0336:  XORLW  01
0337:  BTFSC  03.2
0338:  GOTO   349
0339:  XORLW  03
033A:  BTFSC  03.2
033B:  GOTO   389
033C:  XORLW  01
033D:  BTFSC  03.2
033E:  GOTO   3C9
033F:  XORLW  07
0340:  BTFSC  03.2
0341:  GOTO   3CD
0342:  XORLW  0C
0343:  BTFSC  03.2
0344:  GOTO   40D
0345:  XORLW  04
0346:  BTFSC  03.2
0347:  GOTO   44D
0348:  GOTO   450
....................     
....................       // LINE     
....................       case LINEUP: 
....................          lineChannel++; // Move to main update 
0349:  INCF   53,F
....................          setLineRecChannel(PCFLINERECADDRESS,lineChannel,recChannel,1); // Set the relay 
034A:  MOVLW  40
034B:  MOVWF  5E
034C:  MOVF   53,W
034D:  MOVWF  5F
034E:  MOVF   54,W
034F:  MOVWF  60
0350:  MOVLW  01
0351:  MOVWF  61
0352:  CALL   2C8
....................          sprintf(buffer,"SRC: %s",nameRecLine[lineChannel]); 
0353:  MOVF   53,W
0354:  MOVWF  7A
0355:  MOVLW  00
0356:  MOVWF  5E
0357:  INCF   5E,W
0358:  CALL   044
0359:  MOVWF  7A
035A:  MOVF   5E,W
035B:  CALL   044
035C:  MOVWF  5F
035D:  MOVF   7A,W
035E:  MOVWF  60
035F:  CLRF   5B
0360:  MOVLW  41
0361:  MOVWF  5A
0362:  CLRF   61
0363:  MOVF   61,W
0364:  CALL   084
0365:  INCF   61,F
0366:  MOVWF  77
0367:  MOVWF  6C
0368:  CALL   325
0369:  MOVLW  05
036A:  SUBWF  61,W
036B:  BTFSS  03.2
036C:  GOTO   363
036D:  MOVF   5F,W
036E:  MOVWF  04
036F:  BCF    03.7
0370:  BTFSC  60.0
0371:  BSF    03.7
0372:  MOVLW  00
0373:  IORWF  00,W
0374:  BTFSC  03.2
0375:  GOTO   386
0376:  CLRF   63
0377:  MOVF   04,W
0378:  MOVWF  62
0379:  BCF    63.0
037A:  BTFSC  03.7
037B:  BSF    63.0
037C:  MOVF   00,W
037D:  MOVWF  6C
037E:  CALL   325
037F:  MOVF   62,W
0380:  MOVWF  04
0381:  BCF    03.7
0382:  BTFSC  63.0
0383:  BSF    03.7
0384:  INCF   04,F
0385:  GOTO   372
*
0698:  CLRF   5A
0699:  CLRF   5B
....................           
....................          flagLCDUpdate=1; 
*
0386:  MOVLW  01
0387:  MOVWF  52
....................          break; 
0388:  GOTO   451
....................           
....................       case LINEDOWN: 
....................          lineChannel--; 
0389:  DECF   53,F
....................          setLineRecChannel(PCFLINERECADDRESS,lineChannel,recChannel,1); // Set the relay 
038A:  MOVLW  40
038B:  MOVWF  5E
038C:  MOVF   53,W
038D:  MOVWF  5F
038E:  MOVF   54,W
038F:  MOVWF  60
0390:  MOVLW  01
0391:  MOVWF  61
0392:  CALL   2C8
....................          sprintf(buffer,"SRC: %s",nameRecLine[lineChannel]); 
0393:  MOVF   53,W
0394:  MOVWF  7A
0395:  MOVLW  00
0396:  MOVWF  5E
0397:  INCF   5E,W
0398:  CALL   044
0399:  MOVWF  7A
039A:  MOVF   5E,W
039B:  CALL   044
039C:  MOVWF  5F
039D:  MOVF   7A,W
039E:  MOVWF  60
039F:  CLRF   5B
03A0:  MOVLW  41
03A1:  MOVWF  5A
03A2:  CLRF   61
03A3:  MOVF   61,W
03A4:  CALL   084
03A5:  INCF   61,F
03A6:  MOVWF  77
03A7:  MOVWF  6C
03A8:  CALL   325
03A9:  MOVLW  05
03AA:  SUBWF  61,W
03AB:  BTFSS  03.2
03AC:  GOTO   3A3
03AD:  MOVF   5F,W
03AE:  MOVWF  04
03AF:  BCF    03.7
03B0:  BTFSC  60.0
03B1:  BSF    03.7
03B2:  MOVLW  00
03B3:  IORWF  00,W
03B4:  BTFSC  03.2
03B5:  GOTO   3C6
03B6:  CLRF   63
03B7:  MOVF   04,W
03B8:  MOVWF  62
03B9:  BCF    63.0
03BA:  BTFSC  03.7
03BB:  BSF    63.0
03BC:  MOVF   00,W
03BD:  MOVWF  6C
03BE:  CALL   325
03BF:  MOVF   62,W
03C0:  MOVWF  04
03C1:  BCF    03.7
03C2:  BTFSC  63.0
03C3:  BSF    03.7
03C4:  INCF   04,F
03C5:  GOTO   3B2
....................          flagLCDUpdate=1; 
03C6:  MOVLW  01
03C7:  MOVWF  52
....................          break; 
03C8:  GOTO   451
....................           
....................       case LINEUPDOWN: 
....................          ledButton^= // Toggle the two leds and shut down output (toogle) 
....................          flagLCDUpdate=1; 
03C9:  MOVLW  01
03CA:  MOVWF  52
03CB:  XORWF  55,F
....................          break; 
03CC:  GOTO   451
....................    
....................       // REC 
....................       case RECUP: 
....................          recChannel++; 
03CD:  INCF   54,F
....................          setLineRecChannel(PCFLINERECADDRESS,lineChannel,recChannel,1); // Set the relay 
03CE:  MOVLW  40
03CF:  MOVWF  5E
03D0:  MOVF   53,W
03D1:  MOVWF  5F
03D2:  MOVF   54,W
03D3:  MOVWF  60
03D4:  MOVLW  01
03D5:  MOVWF  61
03D6:  CALL   2C8
....................          sprintf(buffer,"REC: %s",nameRecLine[recChannel]); 
03D7:  MOVF   54,W
03D8:  MOVWF  7A
03D9:  MOVLW  00
03DA:  MOVWF  5E
03DB:  INCF   5E,W
03DC:  CALL   044
03DD:  MOVWF  7A
03DE:  MOVF   5E,W
03DF:  CALL   044
03E0:  MOVWF  5F
03E1:  MOVF   7A,W
03E2:  MOVWF  60
03E3:  CLRF   5B
03E4:  MOVLW  41
03E5:  MOVWF  5A
03E6:  CLRF   61
03E7:  MOVF   61,W
03E8:  CALL   090
03E9:  INCF   61,F
03EA:  MOVWF  77
03EB:  MOVWF  6C
03EC:  CALL   325
03ED:  MOVLW  05
03EE:  SUBWF  61,W
03EF:  BTFSS  03.2
03F0:  GOTO   3E7
03F1:  MOVF   5F,W
03F2:  MOVWF  04
03F3:  BCF    03.7
03F4:  BTFSC  60.0
03F5:  BSF    03.7
03F6:  MOVLW  00
03F7:  IORWF  00,W
03F8:  BTFSC  03.2
03F9:  GOTO   40A
03FA:  CLRF   63
03FB:  MOVF   04,W
03FC:  MOVWF  62
03FD:  BCF    63.0
03FE:  BTFSC  03.7
03FF:  BSF    63.0
0400:  MOVF   00,W
0401:  MOVWF  6C
0402:  CALL   325
0403:  MOVF   62,W
0404:  MOVWF  04
0405:  BCF    03.7
0406:  BTFSC  63.0
0407:  BSF    03.7
0408:  INCF   04,F
0409:  GOTO   3F6
....................          flagLCDUpdate=2; 
040A:  MOVLW  02
040B:  MOVWF  52
....................          break; 
040C:  GOTO   451
....................           
....................       case RECDOWN: 
....................          recChannel--; 
040D:  DECF   54,F
....................          setLineRecChannel(PCFLINERECADDRESS,lineChannel,recChannel,1); // Set the relay 
040E:  MOVLW  40
040F:  MOVWF  5E
0410:  MOVF   53,W
0411:  MOVWF  5F
0412:  MOVF   54,W
0413:  MOVWF  60
0414:  MOVLW  01
0415:  MOVWF  61
0416:  CALL   2C8
....................          sprintf(buffer,"REC: %s",nameRecLine[recChannel]); 
0417:  MOVF   54,W
0418:  MOVWF  7A
0419:  MOVLW  00
041A:  MOVWF  5E
041B:  INCF   5E,W
041C:  CALL   044
041D:  MOVWF  7A
041E:  MOVF   5E,W
041F:  CALL   044
0420:  MOVWF  5F
0421:  MOVF   7A,W
0422:  MOVWF  60
0423:  CLRF   5B
0424:  MOVLW  41
0425:  MOVWF  5A
0426:  CLRF   61
0427:  MOVF   61,W
0428:  CALL   090
0429:  INCF   61,F
042A:  MOVWF  77
042B:  MOVWF  6C
042C:  CALL   325
042D:  MOVLW  05
042E:  SUBWF  61,W
042F:  BTFSS  03.2
0430:  GOTO   427
0431:  MOVF   5F,W
0432:  MOVWF  04
0433:  BCF    03.7
0434:  BTFSC  60.0
0435:  BSF    03.7
0436:  MOVLW  00
0437:  IORWF  00,W
0438:  BTFSC  03.2
0439:  GOTO   44A
043A:  CLRF   63
043B:  MOVF   04,W
043C:  MOVWF  62
043D:  BCF    63.0
043E:  BTFSC  03.7
043F:  BSF    63.0
0440:  MOVF   00,W
0441:  MOVWF  6C
0442:  CALL   325
0443:  MOVF   62,W
0444:  MOVWF  04
0445:  BCF    03.7
0446:  BTFSC  63.0
0447:  BSF    03.7
0448:  INCF   04,F
0449:  GOTO   436
....................          flagLCDUpdate=2; 
044A:  MOVLW  02
044B:  MOVWF  52
....................          break; 
044C:  GOTO   451
....................        
....................       case RECUPDOWN:  // Toggle the two leds and shut down output (toogle) 
....................           
....................          flagLCDUpdate=2; 
044D:  MOVLW  02
044E:  MOVWF  52
....................          break; 
044F:  GOTO   451
....................    
....................       // Default Break 
....................       default: 
....................          break; 
0450:  GOTO   451
....................     
....................    } 
....................     
....................    // Apply the LOUD or DIRECT 
....................     
....................  
.................... } 
0451:  BCF    0A.3
0452:  BCF    0A.4
0453:  GOTO   6E9 (RETURN)
....................  
....................  
.................... // Function: Present the user message to the user 
.................... void initLcd (void){ 
....................  
....................    lcd_init();  
*
0252:  CALL   1F1
....................    delay_ms(2);       
0253:  MOVLW  02
0254:  MOVWF  65
0255:  CALL   196
....................    x=5;y=1;                            // Carregar Posicao 
0256:  MOVLW  05
0257:  MOVWF  57
0258:  MOVLW  01
0259:  MOVWF  58
....................    lcd_gotoxy(x,y);                    // Mandar lcd Posicao 
025A:  MOVF   57,W
025B:  MOVWF  5E
025C:  MOVF   58,W
025D:  MOVWF  5F
025E:  CALL   21B
....................    printf(lcd_putc,"Audio"); // Escreve Lcd 
025F:  CLRF   5C
0260:  MOVF   5C,W
0261:  CALL   09C
0262:  INCF   5C,F
0263:  MOVWF  77
0264:  MOVWF  5D
0265:  CALL   22D
0266:  MOVLW  05
0267:  SUBWF  5C,W
0268:  BTFSS  03.2
0269:  GOTO   260
....................    x=5;y=2; 
026A:  MOVLW  05
026B:  MOVWF  57
026C:  MOVLW  02
026D:  MOVWF  58
....................    lcd_gotoxy(x,y); 
026E:  MOVF   57,W
026F:  MOVWF  5E
0270:  MOVF   58,W
0271:  MOVWF  5F
0272:  CALL   21B
....................    printf(lcd_putc,"PreAmp"); 
0273:  CLRF   5C
0274:  MOVF   5C,W
0275:  CALL   0A6
0276:  INCF   5C,F
0277:  MOVWF  77
0278:  MOVWF  5D
0279:  CALL   22D
027A:  MOVLW  06
027B:  SUBWF  5C,W
027C:  BTFSS  03.2
027D:  GOTO   274
....................    delay_ms(2000); 
027E:  MOVLW  08
027F:  MOVWF  5C
0280:  MOVLW  FA
0281:  MOVWF  65
0282:  CALL   196
0283:  DECFSZ 5C,F
0284:  GOTO   280
....................    printf(lcd_putc,"\f" ) ;   
0285:  MOVLW  0C
0286:  MOVWF  5D
0287:  CALL   22D
....................    x=5;y=1; 
0288:  MOVLW  05
0289:  MOVWF  57
028A:  MOVLW  01
028B:  MOVWF  58
....................    lcd_gotoxy(x,y); 
028C:  MOVF   57,W
028D:  MOVWF  5E
028E:  MOVF   58,W
028F:  MOVWF  5F
0290:  CALL   21B
....................    printf(lcd_putc,"SOUND" ) ; 
0291:  CLRF   5C
0292:  MOVF   5C,W
0293:  CALL   0B1
0294:  INCF   5C,F
0295:  MOVWF  77
0296:  MOVWF  5D
0297:  CALL   22D
0298:  MOVLW  05
0299:  SUBWF  5C,W
029A:  BTFSS  03.2
029B:  GOTO   292
....................    x=3;y=2; 
029C:  MOVLW  03
029D:  MOVWF  57
029E:  MOVLW  02
029F:  MOVWF  58
....................    lcd_gotoxy(x,y); 
02A0:  MOVF   57,W
02A1:  MOVWF  5E
02A2:  MOVF   58,W
02A3:  MOVWF  5F
02A4:  CALL   21B
....................    printf(lcd_putc,"ENGINEERING" ) ; 
02A5:  CLRF   5C
02A6:  MOVF   5C,W
02A7:  CALL   0BB
02A8:  INCF   5C,F
02A9:  MOVWF  77
02AA:  MOVWF  5D
02AB:  CALL   22D
02AC:  MOVLW  0B
02AD:  SUBWF  5C,W
02AE:  BTFSS  03.2
02AF:  GOTO   2A6
....................    delay_ms(2000); 
02B0:  MOVLW  08
02B1:  MOVWF  5C
02B2:  MOVLW  FA
02B3:  MOVWF  65
02B4:  CALL   196
02B5:  DECFSZ 5C,F
02B6:  GOTO   2B2
....................    printf(lcd_putc,"\f" ) ;            // Limpa 
02B7:  MOVLW  0C
02B8:  MOVWF  5D
02B9:  CALL   22D
....................    x=1;y=1; 
02BA:  MOVLW  01
02BB:  MOVWF  57
02BC:  MOVWF  58
....................    lcd_gotoxy(x,y); 
02BD:  MOVF   57,W
02BE:  MOVWF  5E
02BF:  MOVF   58,W
02C0:  MOVWF  5F
02C1:  CALL   21B
....................  
.................... } 
02C2:  BCF    0A.3
02C3:  BCF    0A.4
02C4:  GOTO   6A3 (RETURN)
....................  
....................  
.................... // Function: Delay Routine 
.................... void long_delay_ms(int16 count) {  
.................... unsigned int16 k;  
....................  
.................... for(k = 0; k < count; k++)  
....................     delay_ms(1);  
.................... } 
....................  
....................  
.................... // Function: Config GPIO and modes 
.................... void configGPIO(void){ 
....................  
....................   // Define port mode 
....................    set_tris_a(0b11111111); 
*
018A:  MOVLW  FF
018B:  BSF    03.5
018C:  MOVWF  05
....................    set_tris_b(0x11111111);  
018D:  MOVLW  11
018E:  MOVWF  06
....................    set_tris_c(0b00000000); 
018F:  MOVLW  00
0190:  MOVWF  07
....................    set_tris_d(0b00000000); 
0191:  MOVWF  08
.................... } 
0192:  BCF    03.5
0193:  BCF    0A.3
0194:  BCF    0A.4
0195:  GOTO   69E (RETURN)
....................  
....................  
.................... // Funtion: Setup Analog converter 
.................... void configADC(void){ 
....................    setup_adc(ADC_CLOCK_DIV_32);   //configure analog to digiral converter 
....................    setup_adc_ports(ALL_ANALOG);   //set pins AN0-AN7 to analog  
....................  
.................... } 
....................  
....................  
.................... // Function: Read all the potenciometers channels (Called in the timer) 
.................... void readADCS(void){ 
.................... unsigned int8 i; 
....................  
....................    for(i=0;i<NPOTENTIOMETERS; i++){ 
*
0454:  CLRF   5C
0455:  MOVF   5C,W
0456:  SUBLW  03
0457:  BTFSS  03.0
0458:  GOTO   47E
....................     
....................       set_adc_channel(i); 
0459:  RLF    5C,W
045A:  MOVWF  77
045B:  RLF    77,F
045C:  RLF    77,F
045D:  MOVLW  F8
045E:  ANDWF  77,F
045F:  MOVF   1F,W
0460:  ANDLW  C7
0461:  IORWF  77,W
0462:  MOVWF  1F
....................       delay_us(10); 
0463:  MOVLW  03
0464:  MOVWF  77
0465:  DECFSZ 77,F
0466:  GOTO   465
....................       bufferPotNew[i]=read_adc(); 
0467:  BCF    03.0
0468:  RLF    5C,W
0469:  ADDLW  30
046A:  MOVWF  04
046B:  BCF    03.7
046C:  BSF    1F.2
046D:  BTFSC  1F.2
046E:  GOTO   46D
046F:  MOVF   1E,W
0470:  MOVWF  7A
0471:  BSF    03.5
0472:  MOVF   1E,W
0473:  MOVWF  00
0474:  INCF   04,F
0475:  MOVF   7A,W
0476:  MOVWF  00
....................       delay_us(10); 
0477:  MOVLW  03
0478:  MOVWF  77
0479:  DECFSZ 77,F
047A:  GOTO   479
....................    } 
047B:  BCF    03.5
047C:  INCF   5C,F
047D:  GOTO   455
.................... } 
047E:  BCF    0A.3
047F:  BCF    0A.4
0480:  GOTO   6ED (RETURN)
....................  
....................  
.................... // Function: Check ADC changes to last values and flag updates and prepare lcd buffer to update 
.................... void checkADCChanges(void){ 
.................... unsigned int8 i; 
....................  
....................    
....................    // Check for all channels the ADC threshold 
....................    for(i=0; NPOTENTIOMETERS; i++){ 
*
0510:  CLRF   5C
....................       if(abs(bufferPotNew - bufferPotOld)>ADCTHRESHOLDDETECTION){ 
0511:  MOVLW  38
0512:  SUBLW  30
0513:  MOVWF  77
0514:  CLRF   7A
0515:  MOVLW  00
0516:  BTFSS  03.0
0517:  MOVLW  01
0518:  SUBWF  7A,F
0519:  MOVF   77,W
051A:  BCF    03.0
051B:  CLRF   7A
051C:  CLRF   79
051D:  MOVF   79,W
051E:  MOVLW  7F
051F:  MOVWF  5E
0520:  MOVLW  FC
0521:  MOVWF  5D
0522:  MOVF   5E,W
0523:  MOVWF  7A
0524:  MOVF   5D,W
0525:  MOVF   5E,F
0526:  BTFSS  03.2
0527:  GOTO   52C
0528:  MOVF   5D,W
0529:  SUBLW  05
052A:  BTFSC  03.0
052B:  GOTO   663
....................          bufferPotOld[i] = bufferPotNew[i];  // Update buffer 
052C:  BCF    03.0
052D:  RLF    5C,W
052E:  ADDLW  38
052F:  MOVWF  78
0530:  CLRF   7A
0531:  BTFSC  03.0
0532:  INCF   7A,F
0533:  MOVF   7A,W
0534:  MOVWF  5E
0535:  BCF    03.0
0536:  RLF    5C,W
0537:  ADDLW  30
0538:  MOVWF  04
0539:  BCF    03.7
053A:  INCF   04,F
053B:  MOVF   00,W
053C:  MOVWF  7A
053D:  DECF   04,F
053E:  MOVF   00,W
053F:  MOVWF  5F
0540:  MOVF   78,W
0541:  MOVWF  04
0542:  BCF    03.7
0543:  BTFSC  5E.0
0544:  BSF    03.7
0545:  INCF   04,F
0546:  MOVF   7A,W
0547:  MOVWF  00
0548:  DECF   04,F
0549:  MOVF   5F,W
054A:  MOVWF  00
....................          switch(i){ 
054B:  MOVF   5C,W
054C:  ADDLW  FC
054D:  BTFSC  03.0
054E:  GOTO   660
054F:  ADDLW  04
0550:  GOTO   668
....................             case 0: 
....................                sprintf(buffer,"VOL: %3d",(unsigned int8)(CONVERTADCTOPERCENTAGE(bufferPotNew[i])) ); 
0551:  BCF    03.0
0552:  RLF    5C,W
0553:  ADDLW  30
0554:  MOVWF  04
0555:  BCF    03.7
0556:  INCF   04,F
0557:  MOVF   00,W
0558:  MOVWF  5E
0559:  DECF   04,F
055A:  MOVF   00,W
055B:  MOVWF  5D
055C:  CLRF   60
055D:  RRF    5E,W
055E:  MOVWF  5F
055F:  RRF    5F,F
0560:  MOVLW  3F
0561:  ANDWF  5F,F
0562:  MOVF   60,W
0563:  MOVWF  66
0564:  MOVF   5F,W
0565:  MOVWF  65
0566:  CLRF   68
0567:  MOVLW  64
0568:  MOVWF  67
0569:  CALL   481
056A:  MOVF   78,W
056B:  MOVWF  60
056C:  CLRF   5B
056D:  MOVLW  41
056E:  MOVWF  5A
056F:  CLRF   61
0570:  MOVF   61,W
0571:  CALL   0CB
0572:  INCF   61,F
0573:  MOVWF  77
0574:  MOVWF  6C
0575:  CALL   325
0576:  MOVLW  05
0577:  SUBWF  61,W
0578:  BTFSS  03.2
0579:  GOTO   570
057A:  MOVF   60,W
057B:  MOVWF  66
057C:  MOVLW  13
057D:  MOVWF  67
057E:  CALL   4AB
....................                break; 
057F:  GOTO   660
....................                 
....................             case 1: 
....................                sprintf(buffer,"BAL: L%2d R%2d",(unsigned int8)(100- CONVERTADCTOPERCENTAGE(bufferPotNew[i])),(unsigned int8)CONVERTADCTOPERCENTAGE(bufferPotNew[i])); 
0580:  BCF    03.0
0581:  RLF    5C,W
0582:  ADDLW  30
0583:  MOVWF  04
0584:  BCF    03.7
0585:  INCF   04,F
0586:  MOVF   00,W
0587:  MOVWF  5E
0588:  DECF   04,F
0589:  MOVF   00,W
058A:  MOVWF  5D
058B:  CLRF   60
058C:  RRF    5E,W
058D:  MOVWF  5F
058E:  RRF    5F,F
058F:  MOVLW  3F
0590:  ANDWF  5F,F
0591:  MOVF   60,W
0592:  MOVWF  66
0593:  MOVF   5F,W
0594:  MOVWF  65
0595:  CLRF   68
0596:  MOVLW  64
0597:  MOVWF  67
0598:  CALL   481
0599:  MOVF   79,W
059A:  MOVWF  7A
059B:  MOVF   78,W
059C:  SUBLW  64
059D:  MOVWF  77
059E:  MOVF   79,W
059F:  BTFSS  03.0
05A0:  INCFSZ 79,W
05A1:  GOTO   5A4
05A2:  MOVLW  00
05A3:  GOTO   5A5
05A4:  SUBLW  00
05A5:  MOVWF  7A
05A6:  MOVF   77,W
05A7:  MOVWF  60
05A8:  BCF    03.0
05A9:  RLF    5C,W
05AA:  ADDLW  30
05AB:  MOVWF  04
05AC:  BCF    03.7
05AD:  INCF   04,F
05AE:  MOVF   00,W
05AF:  MOVWF  62
05B0:  DECF   04,F
05B1:  MOVF   00,W
05B2:  MOVWF  61
05B3:  CLRF   64
05B4:  RRF    62,W
05B5:  MOVWF  63
05B6:  RRF    63,F
05B7:  MOVLW  3F
05B8:  ANDWF  63,F
05B9:  MOVF   64,W
05BA:  MOVWF  66
05BB:  MOVF   63,W
05BC:  MOVWF  65
05BD:  CLRF   68
05BE:  MOVLW  64
05BF:  MOVWF  67
05C0:  CALL   481
05C1:  MOVF   78,W
05C2:  MOVWF  64
05C3:  CLRF   5B
05C4:  MOVLW  41
05C5:  MOVWF  5A
05C6:  CLRF   65
05C7:  MOVF   65,W
05C8:  CALL   0D8
05C9:  INCF   65,F
05CA:  MOVWF  77
05CB:  MOVWF  6C
05CC:  CALL   325
05CD:  MOVLW  06
05CE:  SUBWF  65,W
05CF:  BTFSS  03.2
05D0:  GOTO   5C7
05D1:  MOVF   60,W
05D2:  MOVWF  66
05D3:  MOVLW  11
05D4:  MOVWF  67
05D5:  CALL   4AB
05D6:  MOVLW  20
05D7:  MOVWF  6C
05D8:  CALL   325
05D9:  MOVLW  52
05DA:  MOVWF  6C
05DB:  CALL   325
05DC:  MOVF   64,W
05DD:  MOVWF  66
05DE:  MOVLW  11
05DF:  MOVWF  67
05E0:  CALL   4AB
....................                break; 
05E1:  GOTO   660
....................                 
....................             case 2: 
....................                 
....................                sprintf(buffer,"TREB: L%2d dB",(int8)CONVERTADCTODB(bufferPotNew[i])); 
05E2:  BCF    03.0
05E3:  RLF    5C,W
05E4:  ADDLW  30
05E5:  MOVWF  04
05E6:  BCF    03.7
05E7:  INCF   04,F
05E8:  MOVF   00,W
05E9:  MOVWF  5E
05EA:  DECF   04,F
05EB:  MOVF   00,W
05EC:  MOVWF  5D
05ED:  MOVLW  00
05EE:  SUBWF  5D,W
05EF:  MOVWF  5F
05F0:  MOVF   5E,W
05F1:  MOVWF  60
05F2:  MOVLW  02
05F3:  BTFSS  03.0
05F4:  MOVLW  03
05F5:  SUBWF  60,F
05F6:  BCF    03.0
05F7:  CLRF   62
05F8:  RRF    60,W
05F9:  MOVWF  61
05FA:  MOVF   62,W
05FB:  MOVWF  66
05FC:  MOVF   61,W
05FD:  MOVWF  65
05FE:  CLRF   68
05FF:  MOVLW  0C
0600:  MOVWF  67
0601:  CALL   481
0602:  MOVF   78,W
0603:  MOVWF  62
0604:  CLRF   5B
0605:  MOVLW  41
0606:  MOVWF  5A
0607:  CLRF   63
0608:  MOVF   63,W
0609:  CALL   0EB
060A:  INCF   63,F
060B:  MOVWF  77
060C:  MOVWF  6C
060D:  CALL   325
060E:  MOVLW  07
060F:  SUBWF  63,W
0610:  BTFSS  03.2
0611:  GOTO   608
0612:  MOVF   62,W
0613:  MOVWF  66
0614:  MOVLW  11
0615:  MOVWF  67
0616:  CALL   4AB
0617:  MOVLW  20
0618:  MOVWF  6C
0619:  CALL   325
061A:  MOVLW  64
061B:  MOVWF  6C
061C:  CALL   325
061D:  MOVLW  42
061E:  MOVWF  6C
061F:  CALL   325
....................                break; 
0620:  GOTO   660
....................                 
....................             case 3: 
....................              
....................                sprintf(buffer,"BASS: L%2d dB",(int8)CONVERTADCTODB(bufferPotNew[i])); 
0621:  BCF    03.0
0622:  RLF    5C,W
0623:  ADDLW  30
0624:  MOVWF  04
0625:  BCF    03.7
0626:  INCF   04,F
0627:  MOVF   00,W
0628:  MOVWF  5E
0629:  DECF   04,F
062A:  MOVF   00,W
062B:  MOVWF  5D
062C:  MOVLW  00
062D:  SUBWF  5D,W
062E:  MOVWF  5F
062F:  MOVF   5E,W
0630:  MOVWF  60
0631:  MOVLW  02
0632:  BTFSS  03.0
0633:  MOVLW  03
0634:  SUBWF  60,F
0635:  BCF    03.0
0636:  CLRF   62
0637:  RRF    60,W
0638:  MOVWF  61
0639:  MOVF   62,W
063A:  MOVWF  66
063B:  MOVF   61,W
063C:  MOVWF  65
063D:  CLRF   68
063E:  MOVLW  0C
063F:  MOVWF  67
0640:  CALL   481
0641:  MOVF   78,W
0642:  MOVWF  62
0643:  CLRF   5B
0644:  MOVLW  41
0645:  MOVWF  5A
0646:  CLRF   63
0647:  MOVF   63,W
0648:  CALL   0FD
0649:  INCF   63,F
064A:  MOVWF  77
064B:  MOVWF  6C
064C:  CALL   325
064D:  MOVLW  07
064E:  SUBWF  63,W
064F:  BTFSS  03.2
0650:  GOTO   647
0651:  MOVF   62,W
0652:  MOVWF  66
0653:  MOVLW  11
0654:  MOVWF  67
0655:  CALL   4AB
0656:  MOVLW  20
0657:  MOVWF  6C
0658:  CALL   325
0659:  MOVLW  64
065A:  MOVWF  6C
065B:  CALL   325
065C:  MOVLW  42
065D:  MOVWF  6C
065E:  CALL   325
....................                break; 
065F:  GOTO   660
....................                 
....................          }      
....................          flagLCDUpdate=i+3;                    // Save the pot to update ,3,4,5,6 
0660:  MOVLW  03
0661:  ADDWF  5C,W
0662:  MOVWF  52
....................           
....................       } 
....................     
....................    } 
0663:  INCF   5C,F
0664:  GOTO   511
....................     
.................... } 
0665:  BCF    0A.3
0666:  BCF    0A.4
0667:  GOTO   6EE (RETURN)
....................  
....................  
.................... // Function: Set the pga values 
.................... void setPGAValue(unsigned int16 volume, unsigned int16 balance){ 
....................  
.................... } 
*
0670:  BCF    0A.3
0671:  BCF    0A.4
0672:  GOTO   6FF (RETURN)
....................  
....................  
.................... // Function: Set the Tones values 
.................... void setToneValue(unsigned int16 bass, unsigned int16 tremble){ 
....................   
....................   
.................... } 
0673:  BCF    0A.3
0674:  BCF    0A.4
0675:  GOTO   708 (RETURN)
....................  
.................... // Function: Select the line and rec relays 
.................... void setLineRecChannel(unsigned int8 address, unsigned int8 lineChannel,unsigned int8 recChannel, unsigned int8 recActive){ 
.................... unsigned int8 lineChannelDecoded, recChannelDecoded; 
....................    // Translate to the channel 
....................     
....................     
....................    // Disable all 
....................    i2c_start (); 
*
02C8:  BSF    03.5
02C9:  BSF    11.0
02CA:  BTFSC  11.0
02CB:  GOTO   2CA
02CC:  BCF    03.5
02CD:  CLRF   28
02CE:  BTFSC  0B.7
02CF:  BSF    28.7
02D0:  BCF    0B.7
....................    i2c_write (address); 
02D1:  MOVF   5E,W
02D2:  MOVWF  72
02D3:  CALL   133
02D4:  BTFSC  28.7
02D5:  BSF    0B.7
02D6:  CLRF   28
02D7:  BTFSC  0B.7
02D8:  BSF    28.7
02D9:  BCF    0B.7
....................    i2c_write (0x00); 
02DA:  CLRF   72
02DB:  CALL   133
02DC:  BTFSC  28.7
02DD:  BSF    0B.7
02DE:  CLRF   28
02DF:  BTFSC  0B.7
02E0:  BSF    28.7
02E1:  BCF    0B.7
....................    i2c_write (recChannel); 
02E2:  MOVF   60,W
02E3:  MOVWF  72
02E4:  CALL   133
02E5:  BTFSC  28.7
02E6:  BSF    0B.7
....................    i2c_stop(); 
02E7:  BSF    03.5
02E8:  BSF    11.2
02E9:  BTFSC  11.2
02EA:  GOTO   2E9
....................  
....................    // Small Delay 
....................    delay_ms(500); 
02EB:  MOVLW  02
02EC:  BCF    03.5
02ED:  MOVWF  64
02EE:  MOVLW  FA
02EF:  MOVWF  65
02F0:  CALL   196
02F1:  DECFSZ 64,F
02F2:  GOTO   2EE
....................     
....................    // Enable the channel 
....................    i2c_start (); 
02F3:  BSF    03.5
02F4:  BSF    11.0
02F5:  BTFSC  11.0
02F6:  GOTO   2F5
02F7:  BCF    03.5
02F8:  CLRF   28
02F9:  BTFSC  0B.7
02FA:  BSF    28.7
02FB:  BCF    0B.7
....................    i2c_write (address); 
02FC:  MOVF   5E,W
02FD:  MOVWF  72
02FE:  CALL   133
02FF:  BTFSC  28.7
0300:  BSF    0B.7
0301:  CLRF   28
0302:  BTFSC  0B.7
0303:  BSF    28.7
0304:  BCF    0B.7
....................    i2c_write (lineChannel); 
0305:  MOVF   5F,W
0306:  MOVWF  72
0307:  CALL   133
0308:  BTFSC  28.7
0309:  BSF    0B.7
....................    if(recActive >0)i2c_write (recChannel); 
030A:  MOVF   61,F
030B:  BTFSC  03.2
030C:  GOTO   317
030D:  CLRF   28
030E:  BTFSC  0B.7
030F:  BSF    28.7
0310:  BCF    0B.7
0311:  MOVF   60,W
0312:  MOVWF  72
0313:  CALL   133
0314:  BTFSC  28.7
0315:  BSF    0B.7
....................    else i2c_write (0x00); 
0316:  GOTO   31F
0317:  CLRF   28
0318:  BTFSC  0B.7
0319:  BSF    28.7
031A:  BCF    0B.7
031B:  CLRF   72
031C:  CALL   133
031D:  BTFSC  28.7
031E:  BSF    0B.7
....................    i2c_stop(); 
031F:  BSF    03.5
0320:  BSF    11.2
0321:  BTFSC  11.2
0322:  GOTO   321
....................  
.................... } 
0323:  BCF    03.5
0324:  RETLW  00
....................  
....................  
.................... // Function: Update lcd on changes 
.................... void updateLCD(char* buffer){ 
....................  
....................    switch(flagLCDUpdate){ 
....................     
....................       case 1: 
....................          lcd_gotoxy(1,1);printf(lcd_putc,buffer); 
....................           
....................          break; 
....................           
....................       case 2: 
....................          lcd_gotoxy(1,2);printf(lcd_putc,buffer); 
....................           
....................          break; 
....................           
....................       case 3: 
....................          lcd_gotoxy(1,3);printf(lcd_putc,buffer); 
....................           
....................          break; 
....................            
....................       case 4: 
....................          lcd_gotoxy(1,4);printf(lcd_putc,buffer); 
....................           
....................          break; 
....................           
....................           
....................       case 5: 
....................          lcd_gotoxy(1,4);printf(lcd_putc,buffer); 
....................           
....................          break; 
....................           
....................       case 6: 
....................          lcd_gotoxy(1,4);printf(lcd_putc,buffer); 
....................           
....................          break; 
....................           
....................       default: 
....................          break; 
....................     
....................    } 
....................    flagLCDUpdate=0;  // Clear the flag on exit 
....................  
.................... } 
....................  
....................  
....................  
.................... // Function: Save all values (Pot, Channels, REC, Modes) 
.................... void saveCurrentValues(void){ 
....................  
....................    //write_eeprom(0x00,memChannel); 
.................... } 
....................  
....................  
.................... // Function: Restore saved values 
.................... void restoreSavedValues(void){ 
....................    //memChannel=read_eeprom(0x00); 
....................    //channel=memChannel; 
.................... } 
*
02C5:  BCF    0A.3
02C6:  BCF    0A.4
02C7:  GOTO   6E3 (RETURN)
....................  
....................  
.................... // Main Loop the  
.................... void main(void){ 
*
0676:  CLRF   04
0677:  BCF    03.7
0678:  MOVLW  1F
0679:  ANDWF  03,F
067A:  BSF    29.3
067B:  MOVF   29,W
067C:  BSF    03.5
067D:  MOVWF  07
067E:  BCF    03.5
067F:  BSF    29.4
0680:  MOVF   29,W
0681:  BSF    03.5
0682:  MOVWF  07
0683:  MOVLW  09
0684:  MOVWF  13
0685:  MOVLW  28
0686:  BCF    03.5
0687:  MOVWF  14
0688:  BSF    03.5
0689:  BSF    14.7
068A:  BCF    14.6
068B:  BSF    1F.0
068C:  BSF    1F.1
068D:  BSF    1F.2
068E:  BCF    1F.3
068F:  MOVLW  07
0690:  MOVWF  1C
....................  
....................     
....................    enable_interrupts(INT_RB); 
*
069A:  BSF    0B.3
....................    enable_interrupts(GLOBAL); 
069B:  MOVLW  C0
069C:  IORWF  0B,F
....................    configGPIO(); 
069D:  GOTO   18A
....................    port_b_pullups(TRUE); 
069E:  BSF    03.5
069F:  BCF    01.7
....................     
....................     
....................    
....................     
....................  
....................    lcd_init(); 
06A0:  BCF    03.5
06A1:  CALL   1F1
....................    initLcd();  // Show Banner 
06A2:  GOTO   252
....................     
....................     
....................    // Fill the lcd fields ( Static ) 
....................    lcd_gotoxy(1,1); printf(lcd_putc,"SRC:"); 
06A3:  MOVLW  01
06A4:  MOVWF  5E
06A5:  MOVWF  5F
06A6:  CALL   21B
06A7:  CLRF   5C
06A8:  MOVF   5C,W
06A9:  CALL   10F
06AA:  INCF   5C,F
06AB:  MOVWF  77
06AC:  MOVWF  5D
06AD:  CALL   22D
06AE:  MOVLW  04
06AF:  SUBWF  5C,W
06B0:  BTFSS  03.2
06B1:  GOTO   6A8
....................    lcd_gotoxy(1,2); printf(lcd_putc,"REC:"); 
06B2:  MOVLW  01
06B3:  MOVWF  5E
06B4:  MOVLW  02
06B5:  MOVWF  5F
06B6:  CALL   21B
06B7:  CLRF   5C
06B8:  MOVF   5C,W
06B9:  CALL   118
06BA:  INCF   5C,F
06BB:  MOVWF  77
06BC:  MOVWF  5D
06BD:  CALL   22D
06BE:  MOVLW  04
06BF:  SUBWF  5C,W
06C0:  BTFSS  03.2
06C1:  GOTO   6B8
....................    lcd_gotoxy(1,3); printf(lcd_putc,"VOL:"); 
06C2:  MOVLW  01
06C3:  MOVWF  5E
06C4:  MOVLW  03
06C5:  MOVWF  5F
06C6:  CALL   21B
06C7:  CLRF   5C
06C8:  MOVF   5C,W
06C9:  CALL   121
06CA:  INCF   5C,F
06CB:  MOVWF  77
06CC:  MOVWF  5D
06CD:  CALL   22D
06CE:  MOVLW  04
06CF:  SUBWF  5C,W
06D0:  BTFSS  03.2
06D1:  GOTO   6C8
....................    lcd_gotoxy(1,4); printf(lcd_putc,"BAL:"); 
06D2:  MOVLW  01
06D3:  MOVWF  5E
06D4:  MOVLW  04
06D5:  MOVWF  5F
06D6:  CALL   21B
06D7:  CLRF   5C
06D8:  MOVF   5C,W
06D9:  CALL   12A
06DA:  INCF   5C,F
06DB:  MOVWF  77
06DC:  MOVWF  5D
06DD:  CALL   22D
06DE:  MOVLW  04
06DF:  SUBWF  5C,W
06E0:  BTFSS  03.2
06E1:  GOTO   6D8
....................    // Load channel from eeprom and put on channel 
....................    restoreSavedValues(); 
06E2:  GOTO   2C5
....................     
....................    // Main loop 
....................    while(true) 
....................    { 
....................        
....................       // Handle the pressed key 
....................       if(flagKeyPressed){ 
06E3:  MOVF   51,F
06E4:  BTFSC  03.2
06E5:  GOTO   6EA
....................          decodePressedButton(pcfButton);     // decode the key 
06E6:  MOVF   40,W
06E7:  MOVWF  5C
06E8:  GOTO   332
....................           
....................          flagKeyPressed=0;       // Clear the flag 
06E9:  CLRF   51
....................       } 
....................       // Read the ADC for scheduling 
....................       if(flagScheduling==TRUE){ 
06EA:  BTFSS  56.0
06EB:  GOTO   6EF
....................          readADCS(); 
06EC:  GOTO   454
....................          checkADCChanges(); 
06ED:  GOTO   510
....................           
....................          flagScheduling=FALSE;   // Clear the flag 
06EE:  BCF    56.0
....................       } 
....................        
....................       // Update the lcd information if flag enabled(flag remaisn with decode) 
....................       if(flagLCDUpdate>0){ 
06EF:  MOVF   52,F
06F0:  BTFSC  03.2
06F1:  GOTO   709
....................           
....................          if(flagLCDUpdate >3){ // Update PGA 
06F2:  MOVF   52,W
06F3:  SUBLW  03
06F4:  BTFSC  03.0
06F5:  GOTO   708
....................             setPGAValue(bufferPotNew[0], bufferPotNew[1]); 
06F6:  MOVF   31,W
06F7:  MOVWF  5D
06F8:  MOVF   30,W
06F9:  MOVWF  5C
06FA:  MOVF   33,W
06FB:  MOVWF  5F
06FC:  MOVF   32,W
06FD:  MOVWF  5E
06FE:  GOTO   670
....................             setToneValue(bufferPotNew[0], bufferPotNew[3]); 
06FF:  MOVF   31,W
0700:  MOVWF  5D
0701:  MOVF   30,W
0702:  MOVWF  5C
0703:  MOVF   37,W
0704:  MOVWF  5F
0705:  MOVF   36,W
0706:  MOVWF  5E
0707:  GOTO   673
....................           
....................          } 
....................       flagLCDUpdate=0;  // clear the update flag 
0708:  CLRF   52
....................       } 
....................        
....................         
....................    
....................   } 
0709:  GOTO   6E3
.................... } 
....................     
....................  
....................  
070A:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
